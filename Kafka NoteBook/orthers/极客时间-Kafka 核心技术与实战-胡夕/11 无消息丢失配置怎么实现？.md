
Kafka 只对已提交的消息(committed message)做"有限度"的持久化保证.
- 已提交的消息：当Kafka的若干（数量可配置）个Broker成功的接收到一条消息并写入日志。
- 有限度：即必须至少有一个存活的Broker。


案例一：若生产者程序丢失数据

Producer 永远要使用带有回调通知的发送API，也就是说不要使用`producer.send(msg)`,而要使用`producer.send(msg, callback)`。
不要小瞧这里的callback（回调），它能准确的告诉你消息是否真的提交成功了。一旦出现消息提交失败的情况，你就可以有针对性地进行处理。



案例二：消费者程序丢失数据

Consumer 端要消费的消息不见了。采取先消费消息，再更新位移的顺序，可以最大限度的保证消息不丢失。

如果多线程异步处理消费消息，Consumer程序不要开启自动提交位移，而是要应用程序手动提交位移。


- 最佳实践

    - 2 设置 `acks = all`,表明所有的副本Broker都要接收到消息，该消息才算提交。这个是最高等级的‘已提交’定义。
    - 3 设置 `retries`
